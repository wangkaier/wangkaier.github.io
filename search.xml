<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java的反射与内省]]></title>
    <url>%2F2016%2F11%2F16%2Fjava-reflex-introspection%2F</url>
    <content type="text"><![CDATA[反射&nbsp;&nbsp;&nbsp;&nbsp;在运行时把类中的属性和方法映射成相应的类，可以动态得获取属性以及调用方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445//获得Class对象，Class对象封装了一个java类定义的包名、类名、变量、方法。//Class clazz = Class.forname(packageName + className);//Class clazz = object.getClass();Class clazz = className.class;//获取构造器，有零个或多个参数类型Constuctor constuctor = clazz.getConstructor(new Class[]&#123;paramClazz1,paramClazz2,.....&#125;);//通过构造器实例化一个对象，有零个或多个参数Object object = constuctor.newInstance(params....);//直接通过Class的newInstance实例化一个对象，但类必须有无参构造方法 Object object = clazz.newInstance();//获取指定公共成员方法Method method = clazz.getMethod(String name, Class&lt;?&gt;... parameterTypes); //获取Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共成员方法Method[] methods = getMethods();//获取Class对象所表示的类或接口的指定已声明方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法 Method method = getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes);//获取Class对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法 Method[] methods = getDeclaredMethods(); //对带有指定参数的指定对象调用由此Method对象表示的方法。//数组参数被自动解包。如果是静态底层方法，obj可以为null。//如果底层方法所需的形参数为 0，则数组参数长度可以为0或直接为null。method.invoke(Object obj, Object... args);//获取Class对象所表示的类或接口的指定公共成员字段Field field = clazz.getField(fieldName);//获取Class对象所表示的类或接口的所有公共成员字段Field[] fields = clazz.getFields();//获取Class对象所表示的类或接口的指定成员字段Field field = clazz.getDeclaredField(fieldName);//获取Class对象所表示的类或接口的所有成员字段Field[] fields = clazz.getDeclaredFields();//设置值filed.setObject(value); //获得值Object value = field.get(clazz); //获得静态值 Object staticValue = filed.get(Class); 内省&nbsp;&nbsp;&nbsp;&nbsp;在运行时操作JavaBean的属性。该类要符合javaBean规范。 1234567891011121314151617181920212223242526272829// 创建实体类对象Class clazz = className.classObject object = clazz.newInstance();//声明已知属性PropertyDescriptor pd = new PropertyDescriptor(propertyName,Class); //获取setter方法 Method method = pd.getWriterMethod();method .invoke(object, value);//获取getter方法Method method = pd.getReaderMethod();Object value = method.invoke(object);//获取Bean信息BeanInfo beanInfo = Instospector.getBeanInfo(beanClass);//获取属性数组PropertyDescriptor[] pds = beanInfo .getPropertyDescriptors();for(PropertyDescriptor pd : pds)&#123; //找到属性名为propName的属性 if(propName.equals(pd.getName()))&#123; //获取getter方法 pd.getReadMethod(); //获取setter方法 pd.getWriteMethod(); &#125; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git配置SSH以及常见问题]]></title>
    <url>%2F2016%2F10%2F14%2Fgit-ssh%2F</url>
    <content type="text"><![CDATA[一、Git配置SSH1、生成ssh秘钥先在~/.ssh/下查看有无秘钥，没有则ssh-keygen生成。参数 -t 指定密钥类型，默认是 rsa。参数 -C 设置注释文字，比如邮箱。 1$ ssh-keygen -t rsa -C &quot;email@mail.com&quot; 成功后会在~/ssh/下生成id_rsa、id_rsa.pub，前者为私钥，后者为公钥. 2、在github上添加SSH Key用公钥内容在你的github（网页登录）上新建key，在settings中SSH and GPG keys点击New SSH key去新建。3、测试ssh连接git@github.com 1$ ssh -T git@github.com 显示You’ve successfully authenticated就是成功了。4、配置本地git参数参数 –global 表示全局，–local 表示当前， –system表示系统 12$ git config --global user.name "your name"$ git config --global user.email "your email" ok，下次提交代码就不用输入姓名密码了！ 二、常见问题1、ssh可以测试连通github.com，但push时仍要输入账户和密码验证 原因：git push方式为https，即在克隆仓库或者添加仓库源时url为https://形式。 https使用账号密码验证身份，ssh使用ssh验证身份，如果使用ssh克隆仓库必须事前已添加ssh key。 解决：修改为ssh方式，即将仓库源设置为git@github.com:gitname/remotename.git。 两种方法:①、在.git/config中修改url1url=git@github.com:gitname/remotename.git ②、命令修改remote.origin.url1$ git config --replace-all remote.origin.url git@github.com:username/remotename.git 查看git config1$ git config --list 2、ssh: Could not resolve hostname ssh.github.com: Name or service not known 原因：无法解析主机名ssh.github.com。 解决：ssh测试连通github.com。方法： 1$ ssh -T git@github.com]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx启动报错/logs/nginx.pid failed]]></title>
    <url>%2F2016%2F10%2F04%2Fserver-nginx-startError-nginx.pid%2F</url>
    <content type="text"><![CDATA[nginx启动报错 /usr/local/nginx/logs/nginx.pid failed (2: No such file or directory)处理方法。 原因：/usr/local/nginx/logs/下没有nginx.pid文件 解决：使用nginx -c的参数指定nginx.conf文件的位置 -c 命令：1-c filename : set configuration file (default: conf/nginx.conf) 使用nginx -c 命令指定nginx.conf文件的位置1/path/nginx -c /path/nginx/conf/nginx.conf 比如我的nginx在/usr/local/下1$ /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf 然后就可以启动了。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>ngin</tag>
        <tag>报错</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android：抽屉菜单+底部导航主页]]></title>
    <url>%2F2016%2F07%2F20%2Fandroid-drawerLayout-viewPager%2F</url>
    <content type="text"><![CDATA[介绍一种常用的android界面效果，抽屉菜单和底部导航主页，效果如下： 一、实现抽屉菜单 &nbsp;&nbsp;&nbsp;&nbsp;抽屉菜单就是可以从侧边滑出的菜单。这里用DrawerLayout和ActionBarDrawerToggle实现。DrawerLayout是自带滑动效果的布局。如果再绑定上ActionBarDrawerToggle就也可以通过toolBar监听。好比通过ActionBarDrawerToggle再给抽屉加一个把手。 1、首先编辑抽屉菜单的布局吧。将DrawerLayout作为根布局，然后依次嵌套主页面布局和抽屉内容布局。注意抽屉内容布局要设置属性android:layout_gravity=”start”才能让DrawerLayout把它当成抽屉内容处理。主页面布局也需要在抽屉内容布局之前。 实例代码如下：1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/drawer_layout" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;!--主页面布局--&gt; &lt;LinearLayout android:id="@+id/main_content" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/tab_tool_bar" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;/LinearLayout&gt; &lt;!--抽屉菜单--&gt; &lt;LinearLayout android:id="@+id/left_drawer_menu" android:layout_width="280dp" android:layout_height="match_parent" android:layout_gravity="start" android:orientation="vertical"&gt; &lt;ListView android:id="@+id/left_drawer_menu_lv" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;/ListView&gt; &lt;/LinearLayout&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 2、然后在activity中通过ActionBarDrawerToggle给DrawerLayout添加监听事件，ActionBarDrawerToggle实现了DrawerLayout.DrawerListener接口。将ToolBar作为参数传给ActionBarDrawerToggle对象，这样就可以通过点击这个toolBar唤出抽屉。123456789101112131415161718192021222324252627private Toolbar mToolbar;private DrawerLayout mDrawerLayout;private ActionBarDrawerToggle mDrawerToggle;mDrawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout);mToolbar = (Toolbar) findViewById(R.id.tab_tool_bar);setSupportActionBar(mToolbar);getSupportActionBar().setHomeButtonEnabled(true);getSupportActionBar().setDisplayHomeAsUpEnabled(true);mDrawerToggle = new ActionBarDrawerToggle( this, /* host Activity */ mDrawerLayout, /* DrawerLayout object */ mToolbar, R.string.drawer_open, /* "open drawer" description for accessibility */ R.string.drawer_close /* "close drawer" description for accessibility */) &#123; public void onDrawerClosed(View view) &#123; invalidateOptionsMenu(); &#125; public void onDrawerOpened(View drawerView) &#123; invalidateOptionsMenu(); drawerView.setClickable(true); &#125;&#125;;mDrawerToggle.syncState();mDrawerLayout.addDrawerListener(mDrawerToggle); 二、底部导航主页 &nbsp;&nbsp;&nbsp;&nbsp;通过ViewPager来实现左右滑动切换页面，通过在界面底部加一组带监听的tab来点击切换页面。页面使用fragment。 1、在主页面布局添加ViewPager和底部tab。12345678910&lt;!--将这段代码添加到主页面布局main_content中--&gt;&lt;android.support.v4.view.ViewPager android:id="@+id/pager" android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1"&gt;&lt;/android.support.v4.view.ViewPager&gt;&lt;include layout="@layout/footer_tab"/&gt; footer_tab.xml的代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="60dp" android:background="@color/tomato" android:orientation="horizontal" &gt; &lt;LinearLayout android:id="@+id/main_footer_tab" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;LinearLayout android:id="@+id/id_tab_first" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" android:gravity="center" android:orientation="vertical" &gt; &lt;ImageButton android:id="@+id/id_tab_first_img" android:layout_width="wrap_content" android:layout_height="wrap_content" android:background="#00000000" android:clickable="false" android:src="@drawable/ic_menu_share" /&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="first" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id="@+id/id_tab_second" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" android:gravity="center" android:orientation="vertical" &gt; &lt;ImageButton android:id="@+id/id_tab_second_img" android:layout_width="wrap_content" android:layout_height="wrap_content" android:background="#00000000" android:clickable="false" android:src="@drawable/ic_menu_gallery" /&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="second" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id="@+id/id_tab_third" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" android:gravity="center" android:orientation="vertical" &gt; &lt;ImageButton android:id="@+id/id_tab_third_img" android:layout_width="wrap_content" android:layout_height="wrap_content" android:background="#00000000" android:clickable="false" android:src="@drawable/ic_menu_gallery" /&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="third" /&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 2、给ViewPager绑定适配器，设置ViewPager的监听事件以及底部tab的监听事件。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899private ViewPager mViewPager;private ViewPagerAdapter mViewPagerAdapter;private LinearLayout mTabFirstLayout;private LinearLayout mTabSecondLayout;private LinearLayout mTabThirdLayout;private ImageButton mTabFirstImg;private ImageButton mTabSecondImg;private ImageButton mTabThirdImg;mTabFirstLayout = (LinearLayout) findViewById(R.id.id_tab_first);mTabSecondLayout = (LinearLayout) findViewById(R.id.id_tab_second);mTabThirdLayout = (LinearLayout) findViewById(R.id.id_tab_third);mTabFirstImg = (ImageButton) findViewById(R.id.id_tab_first_img);mTabSecondImg = (ImageButton) findViewById(R.id.id_tab_second_img);mTabThirdImg = (ImageButton) findViewById(R.id.id_tab_third_img);mViewPager = (ViewPager)findViewById(R.id.pager);mViewPagerAdapter = new ViewPagerAdapter(getSupportFragmentManager());mViewPager.setAdapter(mViewPagerAdapter);mTabFirstLayout.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View arg0) &#123; mViewPager.setCurrentItem(0); resetImg(); mTabFirstImg.setImageResource(R.drawable.ic_menu_share); &#125;&#125;);mTabSecondLayout.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View arg0) &#123; mViewPager.setCurrentItem(1); resetImg(); mTabSecondImg.setImageResource(R.drawable.ic_menu_camera); &#125;&#125;);mTabThirdLayout.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View arg0) &#123; mViewPager.setCurrentItem(2); resetImg(); mTabThirdImg.setImageResource(R.drawable.ic_menu_manage); &#125;&#125;);mViewPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener()&#123; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123;&#125; @Override public void onPageSelected(int arg0) &#123; int currentItem = mViewPager.getCurrentItem(); switch (currentItem) &#123; case 0: resetImg(); setTitle("first"); mTabFirstImg.setImageResource(R.drawable.ic_menu_share); break; case 1: resetImg(); setTitle("second"); mTabSecondImg.setImageResource(R.drawable.ic_menu_camera); break; case 2: resetImg(); setTitle("third"); mTabThirdImg.setImageResource(R.drawable.ic_menu_manage); break; default: break; &#125; &#125; @Override public void onPageScrollStateChanged(int state) &#123;&#125;&#125;);private void resetImg()&#123; mTabFirstImg.setImageResource(R.drawable.ic_menu_gallery); mTabSecondImg.setImageResource(R.drawable.ic_menu_gallery); mTabThirdImg.setImageResource(R.drawable.ic_menu_gallery);&#125;private class ViewPagerAdapter extends FragmentPagerAdapter &#123; public ViewPagerAdapter(FragmentManager fm) &#123; super(fm); &#125; @Override public Fragment getItem(int position) &#123; switch (position) &#123; case TAB_INDEX_ONE: return mFirstFragment; case TAB_INDEX_TWO: return mSecondFragment; case TAB_INDEX_THREE: return mThirdFragment; &#125; throw new IllegalStateException("No fragment at position " + position); &#125; @Override public int getCount() &#123; return TAB_INDEX_COUNT; &#125;&#125; 完整的MainActivity.java代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215import android.content.res.Configuration;import android.graphics.Color;import android.os.Bundle;import android.support.v4.app.Fragment;import android.support.v4.app.FragmentManager;import android.support.v4.app.FragmentPagerAdapter;import android.support.v4.view.GravityCompat;import android.support.v4.view.ViewPager;import android.support.v4.widget.DrawerLayout;import android.support.v7.app.ActionBarDrawerToggle;import android.support.v7.app.AppCompatActivity;import android.support.v7.widget.Toolbar;import android.view.View;import android.widget.AdapterView;import android.widget.ArrayAdapter;import android.widget.ImageButton;import android.widget.LinearLayout;import android.widget.ListView;import android.widget.Toast;public class MainActivity extends AppCompatActivity&#123; private Fragment mFirstFragment = new FirstFragment(); private Fragment mSecondFragment = new SecondFragment(); private Fragment mThirdFragment = new ThirdFragment(); private static final int TAB_INDEX_ONE = 0; private static final int TAB_INDEX_TWO = 1; private static final int TAB_INDEX_THREE = 2; private static final int TAB_INDEX_COUNT = 3; private ViewPager mViewPager; private ViewPagerAdapter mViewPagerAdapter; private LinearLayout mTabFirstLayout; private LinearLayout mTabSecondLayout; private LinearLayout mTabThirdLayout; private ImageButton mTabFirstImg; private ImageButton mTabSecondImg; private ImageButton mTabThirdImg; private Toolbar mToolbar; private DrawerLayout mDrawerLayout; private ActionBarDrawerToggle mDrawerToggle; private LinearLayout mLeftMenuLayout; private ListView mLeftMenuLv; private String[] mLeftMenuLvArrays; private CharSequence mTitle; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); initLeftDrawer(); initEvent(); &#125; private void initView()&#123; mTabFirstLayout = (LinearLayout) findViewById(R.id.id_tab_first); mTabSecondLayout = (LinearLayout) findViewById(R.id.id_tab_second); mTabThirdLayout = (LinearLayout) findViewById(R.id.id_tab_third); mTabFirstImg = (ImageButton) findViewById(R.id.id_tab_first_img); mTabSecondImg = (ImageButton) findViewById(R.id.id_tab_second_img); mTabThirdImg = (ImageButton) findViewById(R.id.id_tab_third_img); mViewPager = (ViewPager)findViewById(R.id.pager); mToolbar = (Toolbar) findViewById(R.id.tab_tool_bar); mDrawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout); mLeftMenuLayout = (LinearLayout) findViewById(R.id.left_drawer_menu); mLeftMenuLv = (ListView) findViewById(R.id.left_drawer_menu_lv); mLeftMenuLvArrays = getResources().getStringArray(R.array.menu_array); mViewPagerAdapter = new ViewPagerAdapter(getSupportFragmentManager()); mViewPager.setAdapter(mViewPagerAdapter); &#125; private void initLeftDrawer()&#123; mToolbar.setTitleTextColor(Color.parseColor("#ffffff")); setSupportActionBar(mToolbar); getSupportActionBar().setHomeButtonEnabled(true); getSupportActionBar().setDisplayHomeAsUpEnabled(true); mDrawerToggle = new ActionBarDrawerToggle( this, /* host Activity */ mDrawerLayout, /* DrawerLayout object */ mToolbar, R.string.drawer_open, /* "open drawer" description for accessibility */ R.string.drawer_close /* "close drawer" description for accessibility */ ) &#123; public void onDrawerClosed(View view) &#123; invalidateOptionsMenu(); &#125; public void onDrawerOpened(View drawerView) &#123; invalidateOptionsMenu(); drawerView.setClickable(true); &#125; &#125;; mDrawerToggle.syncState(); mDrawerLayout.addDrawerListener(mDrawerToggle); mLeftMenuLv.setAdapter(new ArrayAdapter( this, android.R.layout.simple_list_item_1, mLeftMenuLvArrays)); mLeftMenuLv.setOnItemClickListener(new DrawerItemClickListener()); &#125; private void initEvent()&#123; mTabFirstLayout.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View arg0) &#123; mViewPager.setCurrentItem(0); resetImg(); mTabFirstImg.setImageResource(R.drawable.ic_menu_share); &#125; &#125;); mTabSecondLayout.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View arg0) &#123; mViewPager.setCurrentItem(1); resetImg(); mTabSecondImg.setImageResource(R.drawable.ic_menu_camera); &#125; &#125;); mTabThirdLayout.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View arg0) &#123; mViewPager.setCurrentItem(2); resetImg(); mTabThirdImg.setImageResource(R.drawable.ic_menu_manage); &#125; &#125;); mViewPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener()&#123; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123;&#125; @Override public void onPageSelected(int arg0) &#123; int currentItem = mViewPager.getCurrentItem(); switch (currentItem) &#123; case 0: resetImg(); setTitle("first"); mTabFirstImg.setImageResource(R.drawable.ic_menu_share); break; case 1: resetImg(); setTitle("second"); mTabSecondImg.setImageResource(R.drawable.ic_menu_camera); break; case 2: resetImg(); setTitle("third"); mTabThirdImg.setImageResource(R.drawable.ic_menu_manage); break; default: break; &#125; &#125; @Override public void onPageScrollStateChanged(int state) &#123;&#125; &#125;); &#125; private void resetImg()&#123; mTabFirstImg.setImageResource(R.drawable.ic_menu_gallery); mTabSecondImg.setImageResource(R.drawable.ic_menu_gallery); mTabThirdImg.setImageResource(R.drawable.ic_menu_gallery); &#125; private class ViewPagerAdapter extends FragmentPagerAdapter &#123; public ViewPagerAdapter(FragmentManager fm) &#123; super(fm); &#125; @Override public Fragment getItem(int position) &#123; switch (position) &#123; case TAB_INDEX_ONE: return mFirstFragment; case TAB_INDEX_TWO: return mSecondFragment; case TAB_INDEX_THREE: return mThirdFragment; &#125; throw new IllegalStateException("No fragment at position " + position); &#125; @Override public int getCount() &#123; return TAB_INDEX_COUNT; &#125; &#125; @Override public void onBackPressed() &#123; DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout); if (drawer.isDrawerOpen(GravityCompat.START)) &#123; drawer.closeDrawer(GravityCompat.START); &#125; else &#123; super.onBackPressed(); &#125; &#125; private class DrawerItemClickListener implements ListView.OnItemClickListener &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; Toast.makeText(MainActivity.this, mLeftMenuLvArrays[position], Toast.LENGTH_SHORT).show(); mLeftMenuLv.setItemChecked(position, true); mDrawerLayout.closeDrawer(mLeftMenuLayout); &#125; &#125; @Override public void setTitle(CharSequence title) &#123; mTitle = title; getSupportActionBar().setTitle(mTitle); &#125; /** * When using the ActionBarDrawerToggle, you must call it during * onPostCreate() and onConfigurationChanged()... */ @Override protected void onPostCreate(Bundle savedInstanceState) &#123; super.onPostCreate(savedInstanceState); // Sync the toggle state after onRestoreInstanceState has occurred. mDrawerToggle.syncState(); setTitle("first"); &#125; @Override public void onConfigurationChanged(Configuration newConfig) &#123; super.onConfigurationChanged(newConfig); // Pass any configuration change to the drawer toggls mDrawerToggle.onConfigurationChanged(newConfig); &#125;&#125; 完整的activity_main.xml代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/drawer_layout" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;!--主布局--&gt; &lt;LinearLayout android:id="@+id/main_content" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/tab_tool_bar" android:layout_width="match_parent" android:layout_height="wrap_content" android:background="?attr/colorPrimary" android:minHeight="?attr/actionBarSize"&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;android.support.v4.view.ViewPager android:id="@+id/pager" android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1"&gt; &lt;/android.support.v4.view.ViewPager&gt; &lt;include layout="@layout/footer_tab"/&gt; &lt;/LinearLayout&gt; &lt;!--侧滑菜单--&gt; &lt;LinearLayout android:id="@+id/left_drawer_menu" android:layout_width="280dp" android:layout_height="match_parent" android:background="@color/white" android:layout_gravity="start" android:orientation="vertical"&gt; &lt;ImageView android:id="@+id/left_drawer_menu_iv" android:layout_width="50dp" android:layout_height="50dp" android:layout_marginTop="5dp" android:layout_gravity="center" android:src="@drawable/ic_menu_gallery"/&gt; &lt;TextView android:id="@+id/left_drawer_menu_user_name_tv" android:layout_width="match_parent" android:layout_height="30dp" android:gravity="center" android:text="@string/app_name" android:textColor="@color/black" android:textSize="18sp"/&gt; &lt;ListView android:id="@+id/left_drawer_menu_lv" android:layout_width="match_parent" android:layout_height="match_parent" android:dividerHeight="1.5dp"&gt; &lt;/ListView&gt; &lt;/LinearLayout&gt;&lt;/android.support.v4.widget.DrawerLayout&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android之Fragment]]></title>
    <url>%2F2016%2F07%2F01%2Fandroid-fragment%2F</url>
    <content type="text"><![CDATA[Fragment&nbsp;&nbsp;&nbsp;&nbsp;Fragment（碎片）在Android3.0的时候被引入，主要是给大屏幕设备提供更加灵活的UI支持。当我们在处理复杂的界面时也可以利用Fragment，它可以将界面分割成几个部分，而且自身可以被动态地添加、替换和移除。 Fragment的生命周期&nbsp;&nbsp;&nbsp;&nbsp;Fragment是依存Activity而存在的，因此Fragment的生命周期会收到宿主Activity的生命周期的影响。Fragment的生命周期： Fragment的生命周期方法简单描述如下： void onAttach(Context):当Fragment被绑定到Activity上时回调； void onCreate(Bundle):当Fragment对象创建的时候回调； View onCreateView(LayoutInflater, ViewGroup, Bundle):创建Fragment视图时回调； void onActivityCreated(Bundle):当Fragment所在的Activity的onCreate方法执行完成后时调用； void onDestoryView():销毁视图时回调，Fragment实例仍存在； void onDestory():销毁fragment实例时回调； void onDetech():Fragment与Activity解绑时回调。 Activity与Fragment生命周期的对比： Fragment的使用①先创建自己的Fragment类，需要继承android.app.Fragment类，然后重写它的几个必要的方法。onCreateView()方法返回一个View对象，这个View就是Fragment要显示的视图。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.example.fragment;import android.content.Context;import android.net.Uri;import android.os.Bundle;import android.app.Fragment;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import com.example.test.R;public class TestFragment extends Fragment &#123; // TODO: Rename parameter arguments, choose names that match // the fragment initialization parameters, e.g. ARG_ITEM_NUMBER private static final String ARG_PARAM1 = "param1"; private static final String ARG_PARAM2 = "param2"; // TODO: Rename and change types of parameters private String mParam1; private String mParam2; public TestFragment() &#123; // Required empty public constructor &#125; / * 一般用这个方法创建并获取Fragment对象，并传递数据给Fragment * 以Bundle的形式传递数据 * 这种方式使得Fragment的封装性更好 * @param param1 Parameter 1. * @param param2 Parameter 2. * @return A new instance of fragment TestFragment. */ public static TestFragment newInstance(String param1, String param2) &#123; TestFragment fragment = new TestFragment(); Bundle args = new Bundle(); args.putString(ARG_PARAM1, param1); args.putString(ARG_PARAM2, param2); fragment.setArguments(args); return fragment; &#125; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // 获取创建Fragment时传递的数据，此处数据类型为String if (getArguments() != null) &#123; mParam1 = getArguments().getString(ARG_PARAM1); mParam2 = getArguments().getString(ARG_PARAM2); &#125; &#125; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; // Inflate the layout for this fragment return inflater.inflate(R.layout.fragment_test, container, false); &#125; @Override public void onAttach(Context context) &#123; super.onAttach(context); &#125; @Override public void onDetach() &#123; super.onDetach(); &#125;&#125; ②创建Fragment的视图，这里使用静态xml视图，根据实际需求创建自己的布局，fragment_test.xml文件内容如下：12345678910111213&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.example.fragment.TestFragment"&gt; &lt;!-- TODO: Update blank fragment layout --&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="match_parent" android:text="Hello Fragment" /&gt;&lt;/FrameLayout&gt; ③在Activity中使用，分为静态使用和动态使用。静态使用不可变，Activity中使用的Fragment是固定的。而动态使用的Fragment可以动态的添加、替换不同的Fragment。 静态使用：在Activity的布局文件中添加fragment标签，fragment标签的name属性要设置为Fragment的完整包名， 代码如下：1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;fragment android:id="@+id/test_fragment" android:name="com.example.fragment.TestFragment" android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1" /&gt; &lt;TextView android:id="@+id/test_tv" android:layout_width="match_parent" android:layout_height="100dp" android:text="Activity_text"/&gt;&lt;/LinearLayout&gt; 动态使用：先在Activity的布局文件中添加FragmentLayout标签，代码如下：1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;FrameLayout android:id="@+id/frame_layout" android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1"/&gt; &lt;Button android:id="@+id/add_fragment_bt" android:layout_width="match_parent" android:layout_height="80dp" android:text="add fragment"/&gt; &lt;/LinearLayout&gt; 再在Activity代码中给FrameLayout动态添加Fragment，代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041package com.example.test;import android.app.Activity;import android.app.FragmentManager;import android.app.FragmentTransaction;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.FrameLayout;import com.example.test.R;import com.example.fragment.TestFragment;public class TestActivity extends Activity &#123; private FrameLayout mFrameLayout; private Button mAddBt; private TestFragment mTestFragment; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_test); // 初始化FrameLayout mFrameLayout = (FrameLayout) findViewById(R.id.frame_layout); mAddBt = (Button) findViewById(R.id.add_fragment_bt); // 新建并获取TestFragment对象，同时传递了两个字符串数据给TestFragment对象 mTestFragment = TestFragment.newInstance("hello", "fragment"); mAddBt.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; // 获取FragmentManager对象，用来管理Fragment对象 FragmentManager fragmentManager = getFragmentManager(); // 开启事务，类似于数据库中的事务 FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); // 添加mTestFragment给frame_layout fragmentTransaction.add(R.id.frame_layout, mTestFragment); // 提交事务 fragmentTransaction.commit(); &#125; &#125;); &#125;&#125; Fragment的管理FragmentManager和FragmentTransaction事务&nbsp;&nbsp;&nbsp;&nbsp;Fragment使用FragmentManager对象管理，FragmentManager对象不能直接new，需要用Context.getFragmentManager()方法获取。注意android.app.FragmentManager对应getFragmentManager()，android.support.v4.app.FragmentManager对应getSupportFragmentManager()。&nbsp;&nbsp;&nbsp;&nbsp;Fragment支持事务，可以回滚操作。多步操作在一次提交后也只算一个事务。事务通过getFragmentManager().beginTransaction()开启，返回一个FragmentTransaction对象，在操作完成后需要commit()提交事务。 FragmentTransaction的几个方法： add()：往容器中添加一个Fragment； replace()：使用另一个Fragment替换当前的Fragment； remove()：从容器中移除一个Fragment，如果被移除的Fragment没有添加事务到回退栈，那么这个Fragment实例将会被销毁； hide() ：隐藏当前的Fragment，将视图设为不可见，实例并不会销毁； show()：显示之前隐藏的Fragment，将视图设为可见； addToBackStack()：将当前事务添加到回退栈，并不是将fragment添加到回退栈。getFragmentManager().popBackStack()这个函数操作的是栈中的事务，并不是fragment实例。它将栈顶事务出栈，并重现新栈顶事务。 演示一下① 先分别add A，add B，add C后，而且是每添加一个fragment就commit提交一次事务。界面依次叠加显示了first_fragment，second_fragment，thrid_fragment。三个fragment的回调方法如下：1234567891011121314151617:37.754 8104-8104/com.example.demo D/FirstFragment: onAttach:37.755 8104-8104/com.example.demo D/FirstFragment: onCreate:37.755 8104-8104/com.example.demo D/FirstFragment: onCreateView:37.759 8104-8104/com.example.demo D/FirstFragment: onStart:37.759 8104-8104/com.example.demo D/FirstFragment: onResume:40.535 8104-8104/com.example.demo D/SecondFragment: onAttach:40.535 8104-8104/com.example.demo D/SecondFragment: onCreate:40.535 8104-8104/com.example.demo D/SecondFragment: onCreateView:40.538 8104-8104/com.example.demo D/SecondFragment: onStart:40.539 8104-8104/com.example.demo D/SecondFragment: onResume:42.347 8104-8104/com.example.demo D/ThirdFragment: onAttach:42.347 8104-8104/com.example.demo D/ThirdFragment: onCreate:42.348 8104-8104/com.example.demo D/ThirdFragment: onCreateView:42.353 8104-8104/com.example.demo D/ThirdFragment: onStart:42.353 8104-8104/com.example.demo D/ThirdFragment: onResume 当执行三次popBackStack()后，三个fragment依次销毁视图和实例即栈顶事务出栈并显示上一次事务，回调各自的方法如下：1234567891011121314151617:14.985 8104-8104/com.example.demo D/ThirdFragment: onPause:14.985 8104-8104/com.example.demo D/ThirdFragment: onStop:14.985 8104-8104/com.example.demo D/ThirdFragment: onDestroyView:14.985 8104-8104/com.example.demo D/ThirdFragment: onDestroy:14.985 8104-8104/com.example.demo D/ThirdFragment: onDetach:17.283 8104-8104/com.example.demo D/SecondFragment: onPause:17.284 8104-8104/com.example.demo D/SecondFragment: onStop:17.284 8104-8104/com.example.demo D/SecondFragment: onDestroyView:17.284 8104-8104/com.example.demo D/SecondFragment: onDestroy:17.284 8104-8104/com.example.demo D/SecondFragment: onDetach:17.922 8104-8104/com.example.demo D/FirstFragment: onPause:17.922 8104-8104/com.example.demo D/FirstFragment: onStop:17.922 8104-8104/com.example.demo D/FirstFragment: onDestroyView:17.922 8104-8104/com.example.demo D/FirstFragment: onDestroy:17.922 8104-8104/com.example.demo D/FirstFragment: onDetach 一次add三个fragment后，再commit提交事务后，popBackStack( )一次三个fragment全部被销毁视图和实例。 ②先add B，执行如下代码，1getFragmentManager().beginTransaction().add(R.id.frame_layout, mSecondFragment).addToBackStack(null).commit();将second_fragment添加到容器中，再replace A,执行如下代码，1getFragmentManager().beginTransaction().replace(R.id.frame_layout, mFirstFragment).addToBackStack(null).commit();可看到second_fragment被替换成first_fragment，且视图没有覆盖，replace()相当于remove()+add()。回调如下：123456789101112131415:46.979 8051-8051/com.example.demo D/SecondFragment: onAttach:46.979 8051-8051/com.example.demo D/SecondFragment: onCreate:46.979 8051-8051/com.example.demo D/SecondFragment: onCreateView:46.983 8051-8051/com.example.demo D/SecondFragment: onStart:46.983 8051-8051/com.example.demo D/SecondFragment: onResume:49.563 8051-8051/com.example.demo D/SecondFragment: onPause:49.563 8051-8051/com.example.demo D/SecondFragment: onStop:49.563 8051-8051/com.example.demo D/SecondFragment: onDestroyView:49.563 8051-8051/com.example.demo D/FirstFragment: onAttach:49.564 8051-8051/com.example.demo D/FirstFragment: onCreate:49.564 8051-8051/com.example.demo D/FirstFragment: onCreateView:49.567 8051-8051/com.example.demo D/FirstFragment: onStart:49.567 8051-8051/com.example.demo D/FirstFragment: onResume然后popBackStack( )一次，FirstFragment被销毁视图和实例，SecondFragment的视图被重新创建，说明replace后并没有销毁原来fragment的实例，只是销毁了它的视图，再popBackStack( )一次，SecondFragment被销毁视图和实例。回调如下：1234567891011121314:53.018 8051-8051/com.example.demo D/FirstFragment: onPause:53.018 8051-8051/com.example.demo D/FirstFragment: onStop:53.018 8051-8051/com.example.demo D/FirstFragment: onDestroyView:53.018 8051-8051/com.example.demo D/FirstFragment: onDestroy:53.018 8051-8051/com.example.demo D/FirstFragment: onDetach:53.018 8051-8051/com.example.demo D/SecondFragment: onCreateView:53.021 8051-8051/com.example.demo D/SecondFragment: onStart:53.022 8051-8051/com.example.demo D/SecondFragment: onResume:53.902 8051-8051/com.example.demo D/SecondFragment: onPause:53.902 8051-8051/com.example.demo D/SecondFragment: onStop:53.902 8051-8051/com.example.demo D/SecondFragment: onDestroyView:53.902 8051-8051/com.example.demo D/SecondFragment: onDestroy:53.902 8051-8051/com.example.demo D/SecondFragment: onDetach③先add B，添加second_fragment到容器中，再remove B，从容器中移除second_fragment，代码如下：1getFragmentManager().beginTransaction().remove(mSecondFragment).addToBackStack(null).commit();回调如下：123456789:31:11.645 8051-8051/com.example.demo D/SecondFragment: onAttach:31:11.645 8051-8051/com.example.demo D/SecondFragment: onCreate:31:11.645 8051-8051/com.example.demo D/SecondFragment: onCreateView:31:11.649 8051-8051/com.example.demo D/SecondFragment: onStart:31:11.649 8051-8051/com.example.demo D/SecondFragment: onResume:31:13.178 8051-8051/com.example.demo D/SecondFragment: onPause:31:13.178 8051-8051/com.example.demo D/SecondFragment: onStop:31:13.179 8051-8051/com.example.demo D/SecondFragment: onDestroyView然后popBackStack()一次,remove B的那次事务被弹出栈，add B的那次事务回到栈顶，second_fragment视图被重新创建。当再popBackStack()一次后它的视图和实例都被销毁。123456789:32:12.990 8051-8051/com.example.demo D/SecondFragment: onCreateView:32:12.993 8051-8051/com.example.demo D/SecondFragment: onStart:32:12.993 8051-8051/com.example.demo D/SecondFragment: onResume:32:27.762 8051-8051/com.example.demo D/SecondFragment: onPause:32:27.762 8051-8051/com.example.demo D/SecondFragment: onStop:32:27.762 8051-8051/com.example.demo D/SecondFragment: onDestroyView:32:27.762 8051-8051/com.example.demo D/SecondFragment: onDestroy:32:27.762 8051-8051/com.example.demo D/SecondFragment: onDetach]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android之五种数据存储方式]]></title>
    <url>%2F2016%2F06%2F29%2Fandroid-data-store%2F</url>
    <content type="text"><![CDATA[下面将介绍Android的五种数据存储方式，包括文件存储、SharePreferences存储、SQLite数据库存储、ContentProvider存储、网络存储。 1. 文件存储&nbsp;&nbsp;&nbsp;&nbsp;Android中的文件存储与java中IO存储类似，生成的文件在/data/data/&lt; package-name&gt;/files目录下。 1.1 写入文件&nbsp;&nbsp;&nbsp;&nbsp;先调用Context.openFileOutput(filename, mode)方法，该方法会返回一个FileOutputStream对象，再通过FileOutputStream对象的write()方法写入数据，最后必须调用FileOutputStream对象的close()方法关闭流。Context.openFileOutput(filename, mode)方法的两个参数中，file为文件名，namemode参数用于指定操作模式。 mode四种模式如下： Context.MODE_PRIVATE 为默认操作模式，私有文件，且写入的内容会覆盖原文件的内容； Context.MODE_APPEND 该模式会检查文件是否存在，存在就在文件末尾追加内容，否则就创建新文件； Context.MODE_WORLD_READABLE 表示当前文件可以被其他应用读取，但不能写； Context.MODE_WORLD_WRITEABLE 表示当前文件可以被其他应用读、写。 1234567891011String filename= "test.txt";String data= "123456abcdef";try &#123; FileOutputStream out= openFileOutput(filename, Context.MODE_PRIVATE); out.write(data.getBytes()); // 关闭流 out.close();&#125; catch (Exception e) &#123; e.printStackTrace();&#125; 1.2 读取文件&nbsp;&nbsp;&nbsp;&nbsp;先调用Context.openFileInput(filename)方法，该方法会返回一个FileInputStream对象。然后使用流对象的read()方法读取字节，最后必须调用流的close()方法关闭流。 1234567891011121314String filename = "test.txt";try &#123; FileInputStream in = openFileInput(filename); int len = 0; byte[] buf = new byte[1024]; StringBuilder sBuilder = new StringBuilder(); while ((len = in.read(buf)) != -1) &#123; sBuilder.append(new String(buf, 0, len)); &#125; // 关闭流 in.close();&#125; catch (Exception e) &#123; e.printStackTrace();&#125; 2. SharePreferences存储&nbsp;&nbsp;&nbsp;&nbsp;SharePreferences使用键值对的方式来存储数据。这种方法适合保存少量的简单格式数据，如字符串型、基本类型的值。比如应用程序的配置信息，生成的数据文件保存为/data/data/&lt; package-name&gt;/shared_prefs/路径下的file_name.xml。&nbsp;&nbsp;&nbsp;&nbsp;但SharedPreferences只能获取数据而不支持存储和修改,存储和修改需要通过SharedPreferences.edit()获取的内部接口Editor对象实现。SharedPreferences无法直接创建实例，只能通过Context.getSharedPreferences(String name, int mode)方法来获取SharedPreferences实例，该方法参数中name表示要操作的文件名，mode为操作模式。 mode操作模式： Context.MODE_PRIVATE 数据只能被本应用读、写； Context.MODE_WORLD_READABLE 数据能被其他应用读，但不能写； Context.MODE_WORLD_WRITEABLE 数据能被其他应用读、写； Context.MODE_MULTI_PROCESS 数据可被多个程序共享,使用前会检查数据是否被更改。 实例代码如下:123456789101112SharedPreferences pref = Context.getSharedPreferences("userdata",Context.MODE_PRIVATE);SharedPreferences.Editor editor= pref.edit();//从SharedPreferences文件中以键名读取数据String account = pref.getString("account","");String password = pref.getString("password","");//往SharedPreferences文件中以键值对形式写入数据editor.putString("account", "xiaoming");editor.putString("password", "123456");//editor.clear(); 清除SharedPreferences文件中所有数据//editor.remove(String key); 从SharedPreferences文件中以键名删除数据//commit()提交修改editor.commit(); 生成userdata.xml文件内容如下： 12345&lt;?xml version=”1.0″ encoding=”UTF-8″?&gt;&lt;map&gt; &lt;string name="account"&gt;xiaoming&lt;/string&gt; &lt;string name="password"&gt;123456&lt;/string&gt;&lt;/map&gt; 3. SQLite数据库存储&nbsp;&nbsp;&nbsp;&nbsp;SQLite是Android中的轻量级数据库，支持SQL语法。这种方式存储的数据在/data/data/&lt; package-name&gt;/database路径下。①先创建一个DbOpenHelper 类，它继承android.database.sqlite.SQLiteDatabase，用于创建数据库和更新数据库。代码如下： 123456789101112131415161718192021222324252627282930package com.example.database;import android.database.sqlite.SQLiteOpenHelper;import android.content.Context;import android.database.sqlite.SQLiteDatabase;public class DbOpenHelper extends SQLiteOpenHelper &#123; private String CREATE_MSG = "CREATE TABLE user_info(" + "user_id INTEGER PRIMARY KEY AUTOINCREMENT," + "user_name TEXT," + "user_sex INT);"; public dbOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) &#123; super(context, name, factory, version); &#125; /* * 创建数据库 */ @Override public void onCreate(SQLiteDatabase db) &#123; db.execSQL(CREATE_MSG); &#125; /* * 更新数据库版本 */ @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; //... &#125;&#125; ②创建Db操作类，完成增删查改方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.example.database;import android.content.ContentValues;import android.content.Context;import android.database.Cursor;import android.database.sqlite.SQLiteDatabase;public class UserDb &#123; public static final int DB_VERSION = 1; private static SQLiteDatabase db; private static UserDb msgDb; public final String DB_NAME = "user_info"; public UserDb(Context context) &#123; DbOpenHelper dbHelper = new DbOpenHelper(context, DB_NAME, null, DB_VERSION); db = dbHelper.getWritableDatabase(); &#125; // 获取数据库对象 public static synchronized UserDb getInstance(Context context) &#123; if(msgDb == null) &#123; msgDb = new UserDb(context); &#125; return msgDb; &#125; /* * 插入数据 * User为自定义数据模型类，为该示例代码的数据类型,相关代码较为简单没有给出 */ public Boolean saveUser(User user) &#123; if(user != null) &#123; ContentValues values = new ContentValues(); values.put("user_name", user.getmUserName()); values.put("user_sex", user.getmUserSex()); try &#123; db.insert("user_info", null, values); // 也可以自己写SQL语句，用SQLiteDatabase.execSQL(SQL)执行 // db.execSQL("insert into user_info(name, sex) values(?,?)", new String[]&#123;user.getmUserName(), user.getmUserSex()&#125;); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; return true; &#125; return false; &#125; /* * 查询数据 */ public List&lt;User&gt; queryUser() &#123; ArrayList&lt;User&gt; list = new ArrayList&lt;User&gt;(); Cursor cursor = db.query("user_info", null, null, null, null, null, null); // 遍历返回的数据集 if(cursor.moveToFirst()) &#123; do &#123; User user = new User(); user.setmUserId(cursor.getInt(cursor.getColumnIndex("user_id"))); user.setmUserSex(cursor.getString(cursor.getColumnIndex("user_sex"))); user.setmUserName(cursor.getString(cursor.getColumnIndex("user_name"))); list.add(user); &#125; while(cursor.moveToNext()); &#125; // 必须关闭cursor cursor.close(); return list ; &#125; /* * 删除数据 */ public boolean DelUser(String userId) &#123; try &#123; db.delete("user_info", "user_id = ?", new String[]&#123;userId&#125;); &#125; catch(Exception e) &#123; e.printStackTrace(); return false; &#125; return true; &#125; /* * 更新数据 */ public boolean UpdateUser(User user) &#123; if(user != null) &#123; ContentValues values = new ContentValues(); values.put("user_name", user.getmUserName()); values.put("user_sex", user.getmUserSex()); try &#123; db.update("user_info", values, "user_id = ?", new String[]&#123;user.getUserId&#125;); &#125; catch(Exception e) &#123; e.printStackTrace(); return false; &#125; return true; &#125; return false; &#125;&#125; SQLiteDatabase提供的增删查改方法和SQL语句执行方法参数和返回值如下：12345678910//插入数据long insert(String table,String nullColumnHack,ContentValues values)//删除数据int delete(String table,String whereClause,String[] whereArgs)//查询数据Cursor query(String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy, String limit)//更新数据int update(String table, ContentValues values, String whereClause, String[] whereArgs)//执行SQL语句void execSQL(String sql) 4. ContentProvider存储&nbsp;&nbsp;&nbsp;&nbsp;ContentProvider（内容提供者）其为存储和获取数据提供统一的接口，使不同的应用程序之间可以共享数据。其以Uri的形式对外提供数据的访问操作接口，而其他应用则通过ContentResolver类对象根据Uri去访问指定的数据。详情参考《Android之ContentProvider》 5. 网络存储&nbsp;&nbsp;&nbsp;&nbsp;网络存储其实就是Android应用通过访问网络从服务器获取数据和存入数据，主要是掌握Android的网络访问。android.net.*包提供了网络访问方法，还有很多第三方网络访问框架，比如 Volley、OkHttp等。客户端与服务器通信的数据格式一般为JSON、XML和HTML，我们可以利用相关工具类进行转换。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android之Content Provider]]></title>
    <url>%2F2016%2F06%2F28%2Fandroid-contentProvider%2F</url>
    <content type="text"><![CDATA[Content Provider&nbsp;&nbsp;&nbsp;&nbsp;Content Provider是Android四大组件之一，其为存储和获取数据提供统一的接口。使不同的应用程序之间可以共享数据。其以Uri的形式对外提供数据的访问操作接口，而其他应用则通过ContentResolver类对象根据Uri去访问指定的数据。当某个应用通过Content Provider提供了自己的数据接口，不管该应用程序是否启动，其他程序都可以通过该接口来操作其内部的数据。&nbsp;&nbsp;&nbsp;&nbsp;Android为我们提供了多种ContentProvider，比如通讯录、多媒体等，当然我们也可以创建自己的ContentProvider。 Content Provider的应用①URI&nbsp;&nbsp;&nbsp;&nbsp;URI是统一资源标识符，是一个用于标识某一互联网资源名称的字符串。 该种标识允许用户对任何（包括本地和互联网）的资源通过特定的协议进行交互操作。URI由包括确定语法和相关协议的方案所定义。有三个组成部分：访问资源的命名机制、存放资源的主机名、资源自身的名称。比如：12345678URI格式为 scheme://authority/path举例为 content://com.myapp.mycontentprovider/tablename/id①scheme为固定前缀： content://②Authority是一个ContentProvider的唯一标识，外部调用者可以根据这个标识来找到它： com.myapp.mycontentprovider③path表示我们要操作的数据，可以是表名，也可以是文件名: tablename④path后也可以加上id或name，定位到某一行数据，不加的话就是表中所有数据 URI的两个工具类：UriMatcher：用于匹配Uri，匹配后返回结果码。代码如下：1234567891011121314151617181920212223Uri uri= Uri.parse("content://com.myapp.mycontentprovider/tablename");/* 自定义匹配码 */final int NOPARAM = 1;final int PARAM = 2;//常量UriMatcher.NO_MATCH表示不匹配任何路径的返回码UriMatcher uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);//如果用match()方法匹配content://com.myapp.mycontentprovider/tablename，返回匹配码为NOPARAM// 注册uriuriMatcher .addURI("com.myapp.mycontentprovider", "tablename", NOPARAM);//如果用match()方法匹配content://com.com.myapp.mycontentprovider/tablename/id路径，返回匹配码为PARAMuriMatcher.addURI("com.myapp.mycontentprovider", "tablename/#", PARAM);// #号为数字通配符switch (uriMatcher.match(uri)) &#123; case NOPARAM: // break; case PARAM: // break; default: // break;&#125; ContentUris：用于操作Uri路径后面的Id部分。代码如下：123456789// 给uri加上idUri uri = Uri.parse("content://com.myapp.mycontentprovider/tablename");Uri resultUri = ContentUris.withAppendedId(uri, 1); //生成后的Uri为：content://com.myapp.mycontentprovider/tablename/1// 获取uri后的idUri uri = Uri.parse("content://com.myapp.mycontentprovider/tablename/1")long id = ContentUris.parseId(uri);// id为1 ②创建自己的Conten Provider&nbsp;&nbsp;&nbsp;&nbsp;创建自己的Content Provider首先继承android.content.ContentProvider类，再重写它的几个方法。主要是对数据的增删查改方法，代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import android.content.ContentProvider;import android.content.ContentValues;import android.database.Cursor;import android.net.Uri;public class MyContentProvider extends ContentProvider &#123; public MyContentProvider() &#123; &#125; //删除数据 @Override public int delete(Uri uri, String selection, String[] selectionArgs) &#123; // Implement this to handle requests to delete one or more rows. throw new UnsupportedOperationException("Not yet implemented"); &#125; //返回MIME类型的字符串 @Override public String getType(Uri uri) &#123; // TODO: Implement this to handle requests for the MIME type of the data // at the given URI. throw new UnsupportedOperationException("Not yet implemented"); &#125; //插入数据 @Override public Uri insert(Uri uri, ContentValues values) &#123; // TODO: Implement this to handle requests to insert a new row. throw new UnsupportedOperationException("Not yet implemented"); &#125; //初始化 @Override public boolean onCreate() &#123; // TODO: Implement this to initialize your content provider on startup. return false; &#125; //查询数据 @Override public Cursor query(Uri uri, String[] projection, String selection,String[] selectionArgs, String sortOrder) &#123; // TODO: Implement this to handle query requests from clients. throw new UnsupportedOperationException("Not yet implemented"); &#125; //更新数据 @Override public int update(Uri uri, ContentValues values, String selection,String[] selectionArgs) &#123; // TODO: Implement this to handle requests to update one or more rows. throw new UnsupportedOperationException("Not yet implemented"); &#125;&#125; ③注册Content Provider&nbsp;&nbsp;&nbsp;&nbsp;在创建完自己的ContentProvider后，要到AndroidManifest.xml文件进行注册。代码如下：123456&lt;provider android:name="com.myapp.MyContentProvider" android:authorities="com.myapp.mycontentprovider" android:enabled="true" android:exported="true"&gt;&lt;/provider&gt; ④Content Resolver&nbsp;&nbsp;&nbsp;&nbsp;在别的应用中，我们使用Content Resolver类来获取和操作ContentProvider提供的数据。ContentResolver类中提供了和ContentProvider类中签名一样的方法。代码如下：12345678910111213141516171819202122232425262728293031323334353637uri = Uri.parse("content://com.test.mycontentprovider/test"); // 获取ContentResolver对象ContentResolver contentResolver = getContentResolver();// 插入数据ContentValues contentValues = new ContentValues();contentValues.put("name", "ResolverTest");Uri uri = contentResolver.insert(uri, contentValues);Toast.makeText(MainActivity.this, uri.toString(), Toast.LENGTH_LONG).show();// 查找所有数据，contentResolver.query返回的是一个结果集cursor = contentResolver.query(uri, null, null,null, null);while(cursor.moveToNext())&#123; int name = cursor.getColumnIndex("name"); Toast.makeText(MainActivity.this, cursor.getString(name), Toast.LENGTH_SHORT).show();&#125;// 查找id为1的数据cursor = contentResolver.query(uri, null, "_ID=?", new String[] &#123; "1" &#125;, null);//这里要调用cursor.moveToFirst将游标移动到第一条数据if (cursor.moveToFirst() == false) &#123; // Cursor为空 return;&#125;int name = cursor.getColumnIndex("name");Toast.makeText(MainActivity.this, cursor.getString(name), Toast.LENGTH_LONG).show();// 更新数据contentValues.put("name", "Resolver_2");uri = contentResolver.update(uri, contentValues, "_ID=?", new String[]&#123;"1"&#125;);Toast.makeText(MainActivity.this, "updated"+":"+uri, Toast.LENGTH_LONG).show();// 删除id为1的数据contentResolver.delete(uri, "_ID=?", new String[]&#123;"1"&#125;); cursor.close();]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android之Broadcast Receiver]]></title>
    <url>%2F2016%2F06%2F27%2Fandroid-broadcastReceiver%2F</url>
    <content type="text"><![CDATA[Broadcast&nbsp;&nbsp;&nbsp;&nbsp;Android系统或应用程序会在产生某个事件时发送广播，比如网络状态改变、开机、电量改变和接收短信等。应用程序可以监听这些广播并做处理。 Broadcast Receiver&nbsp;&nbsp;&nbsp;&nbsp;Broadcast Receiver是Android四大组件之一，用来接收并响应来自系统和应用中的广播。通常一个广播可以被多个广播接收者所接收。 Broadcast Receiver的生命周期&nbsp;&nbsp;&nbsp;&nbsp;Broadcast Receiver的生命周期是从被调用开始，再到onReceiver方法执行完成之后结束。onReceiver方法必须在10秒内执行完成，否则Android系统会出现ANR（Application Not Responding）异常。所以不要在onReceiver方法中执行耗时的操作。如果需要在BroadcastReceiver中执行耗时的操作，可以通过Intent启动Service来完成，但不能绑定Service。 Broadcast的类型 普通广播 (Normal broadcasts)&nbsp;&nbsp;&nbsp;&nbsp;所有监听该广播的广播接收者都可以监听到该广播，并且是没有先后顺序。异步广播使其可以同一时间被所有的接收者接收到。广播的传递效率比较高，不能停止传播。 有序广播 (Ordered broadcasts)&nbsp;&nbsp;&nbsp;&nbsp;按照广播接收者的优先级顺序接收广播 , 优先级别在 intent-filter 中的 priority 中声明 ，优先级在-1000 到1000 之间 ，值越大优先级越高 。接收者可以拦截广播，即终止广播的继续传播 。优先级高的广播接收者可以在广播中放入信息，传递给下一个广播接收者。 应用内广播（Local Broadcast）&nbsp;&nbsp;&nbsp;&nbsp; 在本应用范围内传播的广播，不会造成隐私数据泄露，不会因为别的应用伪造广播而造成安全隐患。其相比在系统内发送全局广播，更高效。 粘性广播（Sticky Broadcast）&nbsp;&nbsp;&nbsp;&nbsp;粘性广播在发送后，其Intent会一直保留到广播事件结束，这种广播也没有所谓的10秒耗时限制。发送粘性广播需要权限android.Manifest.permission.BROADCAST_STICKY。 系统广播（System Broadcast）&nbsp;&nbsp;&nbsp;&nbsp;Android系统中内置了多种系统广播，每个广播都有特定的action，常用的系统广播对应的action如下： 常用系统广播表：| 系统广播 | action|| :————- |:—–|| 设备启动(仅广播一次) | Intent.ACTION_BOOT_COMPLETED|| 重启设备 | Intent.ACTION_REBOOT|| 充电时或电量发生变化 | Intent.ACTION_BATTERY_CHANGED|| 电池电量低 | Intent.ACTION_BATTERY_LOW|| 电池电量充满 | Intent.ACTION_BATTERY_OKAY|| 屏幕锁屏 | Intent.ACTION_CLOSE_SYSTEM_DIALOGS|| 屏幕被关闭 | Intent.ACTION_SCREEN_OFF|| 屏幕被打开 | Intent.ACTION_SCREEN_ON|| 关闭系统时 | Intent.ACTION_SHUTDOWN|| 按下照相时的拍照按键(硬件按键)时 |Intent.ACTION_CAMERA_BUTTON|| 监听网络变化 | android.net.conn.CONNECTIVITY_CHANGE|| 关闭或打开飞行模式 | Intent.ACTION_AIRPLANE_MODE_CHANGED|| 设备当前设置被改变时 | Intent.ACTION_CONFIGURATION_CHANGED|| 插入耳机时 | Intent.ACTION_HEADSET_PLUG|| 未正确移除SD卡但已取出来时(正确移除方法:设置–SD卡和设备内存–卸载SD卡) | Intent.ACTION_MEDIA_BAD_REMOVAL|| 插入外部储存装置（如SD卡） | Intent.ACTION_MEDIA_CHECKING|| 成功安装APK | Intent.ACTION_PACKAGE_ADDED|| 成功卸载APK | Intent.ACTION_PACKAGE_REMOVED||在系统中添加一个快捷方式 |Intent.ADD_SHORTCUT_ACTION ||列举所有可用的应用 | Intent.ALL_APPS_ACTION||处理拨入的电话 | Intent.ANSWER_ACTION ||拨打电话，被呼叫的联系人在数据中指定 |Intent.CALL_ACTION||拨打紧急电话号码 |Intent.MERGENCY_DIAL_ACTION||日期改变 |Intent.DATE_CHANGED_ACTION| BroadcastReceiver的创建&nbsp;&nbsp;&nbsp;&nbsp;在我们要创建自己的BroadcastReceiver时，需要继承android.content.BroadcastReceiver，并实现其onReceive方法。代码如下：12345678910111213141516package com.example.receiver;import android.content.BroadcastReceiver;import android.content.Intent; import android.util.Log; import android.content.Context; public class MyReceiver() extends BroadcastReceiver&#123; @Override public void onReceive(Context context, Intent intent)&#123; //获取广播中携带的数据，有多种数据类型 String msg = intent.getStringExtra("key"); Log.d("MyReceiver:", "MyReceiver"); &#125;&#125; BroadcastReceiver的注册BroadcastReceiver在创建后也需要先注册才能使用。在Android 的广播机制中,动态注册的BroadcastReceiver优先级是要高于静态注册。 ①静态注册&nbsp;&nbsp;&nbsp;&nbsp;静态注册需要在AndroidManifest.xml文件中配置，代码如下：12345678&lt;receiver android:name="com.example.receiver.MyReceiver"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MY_BROADCAST" android:priority="999" /&gt; &lt;!-- 设置最高优先级 --&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; ②动态注册&nbsp;&nbsp;&nbsp;&nbsp;动态注册的属于常驻型，这个广播接收者会在程序运行的整个过程中一直存在，不会被注销掉，当程序被退出后不会再接收到该广播。动态注册需要在代码中设置IntentFilter和注册BroadcastReceiver，代码如下：123456MyReceiver myReceiver = new MyReceiver(); //创建IntentFilter IntentFilter intentFilter = new IntentFilter(); intentFilter .addAction("android.intent.action.MY_BROADCAST"); //注册registerReceiver(myReceiver, intentFilter); &nbsp;&nbsp;&nbsp;&nbsp;动态注册的BroadcastReceiver跟随注册它组件相关联，所以在组件销毁时需要解除注册，否则系统会抛出一个异常。解除注册代码如下：1unregisterReceiver(myReceiver ); 发送Broadcast&nbsp;&nbsp;&nbsp;&nbsp;广播接收器介绍完呢，那怎么发送广播呢，代码如下：123456789Intent intent = new Intent(); intent.setAction("android.intent.action.MY_BROADCAST");//在广播中放入数据，有多种参数类型的函数供使用intent.putExtra("key", "value");//发送普通广播sendBroadcast(intent);//发送有序广播 //receiverPermission为权限参数，如果为null则表示不要求接收者声明指定的权限，如果不为null，则表示接收者若要接收此广播，需声明指定权限。sendOrderedBroadcast(intent,receiverPermission);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android之Service]]></title>
    <url>%2F2016%2F06%2F25%2Fandroid-service%2F</url>
    <content type="text"><![CDATA[Service&nbsp;&nbsp;&nbsp;&nbsp;服务（Service）是Android四大组件之一，其在后台执行长时间运行的操作，不提供用户界面。当启动一个服务，它将一直在后台运行，即使用户切换到另一个应用程序。一个组件可以绑定到一个服务与它交互，甚至执行进程间通信(IPC)。默认情况下，服务是运行在启动它的应用程序的主线程中的。 Service的生命周期 onCreate()：当Service第一次创建时回调onCreate()。该方法只被回调一次。 onStartCommand()：当其他组件调用startService()方法请求启动Service时回调onStartCommand()。Service启动后会一直在后台运行，即使用户切换到另一个应用程序或者启动它的组件被销毁了。当Service任务执行完以后，需自行调用stopSelf() 或 其他组件调用stopService()方法停止Service。 onBind()：当其他组件调用bindService()方法请求绑定Service时回调onBind()。该方法返回一个IBinder接口，IBinder接口是Service与绑定的组件进行交互的桥梁。若Service未绑定其他组件，则该方法应返回null。 onDestroy()：当Service被销毁时回调onDestroy()，在该方法中做一些释放资源的操作。官方给出的Service的生命周期流程图如下： Service的基本类型 Started&nbsp;&nbsp;&nbsp;&nbsp;当应用以startService()方法被启动时，服务就会开始在后台无限期的运行。通常一个启动的服务执行一个单一的操作而且不会返回结果给调用者。当这个动作执行完成的时候，服务应该停止。 Bound&nbsp;&nbsp;&nbsp;&nbsp;当应用以bindService()方法被启动时，服务就会被绑定。一个绑定的服务会提供一个客户端服务器接口，允许组件与服务进行交互，执行进程间通信(IPC)。绑定服务的生存期和被绑定的应用程序组件一致。 Service应用类型 Local Service：&nbsp;&nbsp;&nbsp;&nbsp;依附在主进程上的服务。 Remote Service：&nbsp;&nbsp;&nbsp;&nbsp;在一个独立进程上的服务。 前台Service：&nbsp;&nbsp;&nbsp;&nbsp;会在通知栏显示Notification。 后台Service：&nbsp;&nbsp;&nbsp;&nbsp;默认的服务。 startService启动的Service：&nbsp;&nbsp;&nbsp;&nbsp;以startService()方法被启动的服务。 bindService启动的Service：&nbsp;&nbsp;&nbsp;&nbsp;以bindService()方法绑定的服务。 以startService启动后又使用bindService 绑定的Service：&nbsp;&nbsp;&nbsp;&nbsp;该Service将会一直在后台运行，onCreate方法只会调用一次，onStartCommand的调用次数与startService调用的次数一致。只调用unBindService不会停止Service，必须再调用stopService或stopSelf来停止服务。 Service的创建&nbsp;&nbsp;&nbsp;&nbsp;创建一个服务需要新建一个Service的子类或一个已有Service子类的子类。再根据需求重写一些回调方法，用于对服务生命周期中的关键节点进行处理，以及向组件提供绑定机制。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.example.service;import android.app.Service;import android.content.Intent;import android.os.Binder;import android.os.IBinder;import android.util.Log;public class MyService extends Service &#123; private MyBinder mBinder = new MyBinder(); @Override public void onCreate() &#123; super.onCreate(); // 前台Service // MyNotification myNotification = new MyNotification(this); // startForeground(12345,myNotification.getNotification()); //关闭前台Service //stopForeground(boolean removeNotification) &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; //... return START_STICKY; &#125; @Override public IBinder onBind(Intent intent) &#123; // ... //以start方式启动返回null，以bound方式启动返回mBinder //return mBinder; return null; &#125; @Override public boolean onUnbind(Intent intent) &#123; //... return super.onUnbind(intent); &#125; @Override public void onDestroy() &#123; //... super.onDestroy(); &#125; public class MyBinder extends Binder &#123; public MyService getService()&#123; return MyService.this; &#125; public void work()&#123; //... Log.i("MyService","work"); &#125; &#125;&#125; onStartCommand()方法的返回值该返回值描述了当系统kill掉该Service之后系统应该如何继续使用该Service。 START_NOT_STICKY：如果在返回过onStartCommand()方法之后系统杀死了该Service，则该Service不会再被系统重建，除非有后续的intents。 START_STICKY：如果在返回过onStartCommand()方法之后系统杀死了该Service（此时记录该Service为started 状态），则之后系统会尝试重新创建该Service并创建之后一定调用onStartCommand()方法,但是不会传递最后一个Intent对象，而是用值为null的Intent对象，除非有后续的intents。 START_REDELIVER_INTENT：如果在返回过onStartCommand()方法之后系统杀死了该Service，则之后系统会重新创建该Service并调用onStartCommand()方法,且该Intent值为最后一次Intent对象。 Service的注册1&lt;service android:name="com.example.MyService"/&gt; Service被started12Intent intent = new Intent(this, MyService.class);startService(intent); Service被bound1234567891011121314151617Intent intent = new Intent(this, MyService.class);bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE);ServiceConnection serviceConnection = new ServiceConnection() &#123; MyService.MyBinder binder = null; //绑定成功时回调 @Override public void onServiceConnected(ComponentName name, IBinder service)&#123; binder =(MyService.MyBinder)service; binder.work(); &#125; //绑定失败时回调 @Override public void onServiceDisconnected(ComponentName name) &#123; binder = null; &#125;&#125;; stopService(Intent intent)1stopService(intent); 以start方式启动的Service，执行stopService后，Service回调onDestroy()方法被销毁。 以bound方式启动的Service，执行stopService后，Service不回调且不会被销毁。 以start方式启动的,然后在bind的Service，执行stopService后，Service不回调且不会被销毁。如果再执行unbindService方法，则Service先回调onUnbind，然后回调onDestroy()方法被销毁。 unbindService(ServiceConnection conn)1unbindService(serviceConnection); 以bound方式启动的Service，执行unbindService后，Service先回调onUnbind，然后回调onDestroy()方法被销毁。 以start方式启动的,然后再bind的Service，执行unbindService后，Service不回调且不会被销毁。如果再执行stopService方法，则Service先回调onUnbind，然后回调onDestroy()方法被销毁。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android之Activity]]></title>
    <url>%2F2016%2F06%2F20%2Fandroid-activity%2F</url>
    <content type="text"><![CDATA[Activity&nbsp;&nbsp;&nbsp;&nbsp;Activity是Android四大组件之一，用于与用户进行交互，每个Activity对应一个界面窗口。我们使用的Android手机软件应用中的界面就是Activity。一个软件有多个界面，也就是有多个Activity,界面可以是全屏的、非全屏的，也可以是悬浮的，而且一个界面可以跳转到另一个界面，也可以将信息传到另一个界面。 Activity的生命周期&nbsp;&nbsp;&nbsp;&nbsp;当我们打开一个界面，就是这个Activity的生命周期的开始。当我们跳转到不同的界面，再到退出应用程序，这期间Activity的状态就一直在变化。 Activity类中控制生命周期的函数如下12345678910public class Activity extends ApplicationContext &#123; protected void onCreate(Bundle icicle); protected void onStart(); protected void onRestart(); protected void onResume(); protected void onFreeze(Bundle outIcicle); protected void onPause(); protected void onStop(); protected void onDestroy();&#125; 看看官网提供的一张描述Activity生命周期的流程图如下: 这些函数中有的在我们实际开发的过程中需要被重写，我们来逐一了解一下它们。 onCreate(Bundle savedInstanceState)： 在Activity被创建时调用，在这个方法里一般会做一些初始化操作，比如加载界面布局资源、初始化数据等等。Bundle 的数据类型是键值对。 onStart()：在Activity被启动时调用。这时的Activity已经可见了，但是没有在前台，所以无法和用户交互。 onResume()：在Activity将要与用户交互时调用。这时的Activity出现在前台并且和用户交互。 onPause()：在Activity被暂停时调用。这时的Activity失去焦点，不在最上层，但是依然可见。这时可以进行持久化用户数据、停止动画，暂停多媒体等不太耗时的操作；释放部分占用的系统资源。因为打开新的Activity时会去回调上一个Activity的onPause方法，也就是新Activity的onResume()方法只能在旧Activity的onPause()方法执行完后才会执行。因此onPause方法中不能做太耗时的操作，耗时的清理工作应该放在onStop方法中。 onStop()：在Activity被停止时调用。这时的Activity被其他Activity完全遮挡，对用户不可见。耗时的清理工作应该放在onStop方法中，Activity 此时仍然存在于内存中，如果在系统内存不足时，系统会直接销毁该Activity。因为这个状态的Activity优先级最低。 onRestart()：在原Activity没有销毁时从停止状态重新启动时调用。比如我们在打开一个Activity后，又打开一个新的Activity或者切换到桌面，第一个Activity就会暂停（执行了onPause和onStop），而当我们再回到第一个Activity时，它的onRestart方法就会被调用。 onDestroy()：在Activity即将被销毁时调用。这是Activity生命周期的最后一个环节，进行回收工作和资源的释放。但是一般情况下，在onPause()和onStop()中大多数的清理工作都已经完成。 &nbsp;&nbsp;&nbsp;&nbsp;Activity的的状态变化也可以像下图这样表示，当一个Activity想要与用户交互时，它的方法就会朝上执行，当它要被销毁时，就会向下执行方法。 异常情况下Activity的生命周期以后再做学习和介绍。Activity栈式管理Activity任务&nbsp;&nbsp;&nbsp;&nbsp;Activity的任务（Task）是执行特定作业时与用户交互的一系列 Activity的有序集合，并有一个TaskId。 Activity栈&nbsp;&nbsp;&nbsp;&nbsp;Activity采用栈式管理.一个应用有一个“先进后出”的任务栈（task stack）也叫回退栈（back stack）,用来记录存放用户开启的activity的。&nbsp;&nbsp;&nbsp;&nbsp;当我们启动一个Activity，系统就会创建一个栈并把这个Activity压进栈并获得焦点。如果当前 Activity 启动了另一个 Activity，则新的 Activity 将被压入栈顶并获得焦点。 前一个 Activity 仍然在栈中，但是处于停止状态，系统会保存这个Activity的当前状态。当用户按下返回键时，当前 Activity 将从栈顶弹出被销毁，前一个 Activity 将位于栈顶。 Activity 在栈中的顺序永远不会改变，当栈中没有Activity时，系统会回收这个任务栈。 Activity的启动模式在默认情况下，当我们多次启动同一个Activity时，系统会在每次都创建一个实例。但在有些时候，我们往往不希望这样做。所以Activity提供了四种启动模式，我们可以灵活应用。 启动模式 standard&nbsp;&nbsp;&nbsp;&nbsp;标准模式，也是系统默认模式。每次启动一个Activity时，系统都会创建一个实例，且不管这个实例是否已经存在。一个任务栈中可以有多个实例，每个实例可以属于不同的任务栈。谁启动了这个Activity,这个Activity实例就会进入启动它的那个Activity所在的栈中。 singleTop：&nbsp;&nbsp;&nbsp;&nbsp;栈顶复用模式。如果要被创建的Activity已经存在于栈顶，那么这个Activity就不会被重复创建，这个Activity的onCreate、onStart方法不会被调用，因为它没有发生改变。而如果要被创建的Activity已经存在但是不在栈顶，那么它仍然会被创建一个实例。 singleTask：&nbsp;&nbsp;&nbsp;&nbsp;栈内复用模式，这是一种单实例模式。只要Activity在一个栈中存在，那么不论启动多少次这个Activity都不会被重新创建实例。如果这个Activity在栈顶就会直接启动，如果不在栈顶，就会将栈内所有在它上面的Activity全部出栈，这时它就会位于栈顶。 singleInstance：&nbsp;&nbsp;&nbsp;&nbsp;单实例模式，这种模式除了拥有singTask的所有特性外，还加了一条特性：这种模式下的Activity只能单独地存在于一个任务栈中。在这种模式的Activity被启动，系统便会为它创建一个新的任务栈，并且任务栈里面只有它一个实例存在，该栈中的这个Activity实例可以被多个应用共享。 怎么给Activity制定启动模式1、在AndroidManifest.xml程序清单中指定launchMode。12345&lt;activity android:name="com.example.MainActivity" android:label="@string/app_name" android:launchMode="singleTop" android:theme="@style/AppTheme"&gt; 2、在Intent中设置flags标志位来指定，这种方式的优先级高于上一种。1234Intent intent =new Intent();intent.setClass(MainActivity.this, MainActivity2.class);intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);startActivity(intent); 常用的flags标志位： FLAG_ACTIVITY_CLEAR_TOP： FLAG_ACTIVITY_NEW_TASK： FLAG_ACTIVITY_NO_HISTORY： FLAG_ACTIVITY_SINGLE_TOP： 应用ActivityActivity的创建&nbsp;&nbsp;&nbsp;&nbsp;创建Activity需要继承android提供的activity类。这里继承最简单的android.app.Activity。12345678910import android.app.Activity;public class MyActivity extends Activity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // 设置视图，R.layout.activity_my为activity_my.xml视图文件的资源ID setContentView(R.layout.activity_my); &#125;&#125; xml视图请参考Android布局 Activity的注册&nbsp;&nbsp;&nbsp;&nbsp;当我们在应用中新建了一个Activity，不要忘了在AndroidManifest.xml清单文件中注册。在Android四大组件中Activity、Service、BroadcastReceiver都是需要注册才会生效的。Activity在AndroidManifest.xml清单文件中注册的方法如下：12345&lt;activity android:name="com.example.MyActivity" android:theme="@style/AppTheme"&gt; &lt;!-- 根据需要，设置其他属性--&gt;&lt;/activity&gt; &nbsp;&nbsp;&nbsp;&nbsp;对于打开应用后需要默认启动的Activity，需要加入Intent-Filter，如下：123456789101112&lt;activity android:name="com.example.MyActivity" android:label="@string/app_name" android:theme="@style/AppTheme"&gt; &lt;!-- 根据需要，设置其他属性--&gt; &lt;intent-filter&gt; &lt;!-- 使应用程序最先启动这个组件 --&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;!-- 使应用程序显示在程序列表里 --&gt; &lt;category android:name="android.intent.category.LAUNCHER"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; Activity的Intent跳转①显式Intent&nbsp;&nbsp;&nbsp;&nbsp;显式Intent，是在构造Intent对象时就指定接收者，这种方式用在知道目标Activity名称的时候，一般是在一个应用程序内部实现的，如下：1234Intent intent =new Intent();/*从Activity_1中跳转到Activity_2*/intent.setClass(Activity_1.this, Activity_2.class);startActivity(intent); ②隐式Intent&nbsp;&nbsp;&nbsp;&nbsp;隐式Intent，是在构造Intent对象时并不知道也不关心接收者是谁，这种方式用在没有明确指出目标Activity的时候，一般是用于在不同应用程序之间。没有明确指出目标，因为它只给出了过滤条件：action、category、data：（scheme、host、path、type、mimeType）。优先级：action-&gt;data-&gt;category。在AndroidManifest.xml清单文件中为Activity设置Intent-Filter如下：123456&lt;intent-filter&gt; &lt;action android:name="..."/&gt; &lt;category android:name="..."/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;data android:scheme="..." android:host="..." android:path="/..." android:type="..."/&gt; &lt;/intent-filter&gt; 在跳转时设置匹配条件如下：12345678910Intent intent = new Intent();/*设置Action匹配条件*/intent.setAction("...");/*设置Category匹配条件*/intent.addCategory("...");/*设置data的scheme、host、path匹配条件*/intent.setData(Uri.parse("..."));/*设置data的scheme、host、path、type匹配条件*/intent.setDataAndType(Uri.parse("..."),String type);startActivity(intent); Activity的信息传递这里暂且先只介绍一种 ①利用Bundle来传递&nbsp;&nbsp;&nbsp;&nbsp;通过Bundle来传递不同Activity之间的数据。Bundle对象针对不同的数据类型都提供了方法,它保存的数据是以key-value(键值对)的形式存在的。123456Intent intent = new Intent();Bundle bundle = new Bundle();bundle.putString(String key, String value);bundle.putDouble(String key, double value);intent.putExtras(bundle);startActivity(intent); &nbsp;&nbsp;&nbsp;&nbsp;在接受数据的Activity中同样是以Bundle的方式解开封装的数据，用getIntent().getExtras() 方法取得随着Bundle对象传递过来的数据。123Bundle bundle = this.getIntent().getExtras();String str = bundle.getString(String key);double dou = bundle.getDouble(String key); Bundle基本类型API表 ②Bitmap③其他Activity的属性1234567891011121314151617181920212223242526272829303132333435363738394041android:allowTaskReparenting = ["true" | "false"]android:alwaysRetainTaskState = ["true" | "false"] android:clearTaskOnLaunch = ["true" | "false"]android:configChanges = ["mcc"|"mnc"|"locale" |"touchscreen"| "keyboard"| "keyboardHidden"| "navigation"|"orientation" |"fontScale"]android:enabled=["true" | "false"] android:excludeFromRecents=["true" | "false"] android:exported=["true" | "false"]android:finishOnTaskLaunch=["true" | "false"]android:icon="drawable resource" android:label="string resource"android:launchMode=["multiple" | "singleTop" |"singleTask" | "singleInstance"]android:multiprocess=["true" | "false"] android:name="string" android:noHistory=["true" | "false"] android:permission="string" android:process="string"android:screenOrientation=["unspecified" | "user" | "behind" |"landscape" | "portrait" | "sensor" | "nonsensor"] android:stateNotNeeded=["true" | "false"]android:taskAffinity="string"android:theme="resource or theme"android:windowSoftInputMode=[one or more of:"stateUnspecified""stateUnchanged""stateHidden""stateAlwaysHidden""stateVisible""stateAlwaysVisible""adjustUnspecified""adjustResize" "adjustPan"]]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC]]></title>
    <url>%2F2016%2F06%2F14%2Fjdbc%2F</url>
    <content type="text"><![CDATA[JDBC（Java DataBase Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。JDBC提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序。 JDBC步骤： 加载JDBC驱动 获取数据库连接 创建一个Statement实例 执行SQL语句并获得查询结果 释放相关资源 Statement实例有三种类型： Statement，执行静态SQL语句 子接口PreparedStatement，执行动态SQL语句，参数化，预编译 子接口CallableStatement，执行数据库存储过程 Statement接口提供了多个执行SQL语句的方法： boolean execute()：执行SQL语句，该语句可以是任何种类的SQL语句。 ResultSet executeQuery()：执行SQL查询，并返回该查询生成的ResultSet对象。 int executeUpdate()：执行SQL语句，该语句可能为 INSERT、UPDATE、DELETE 语句，或者不返回任何内容的SQL语句（如 SQL DDL 语句）。 MySql JDBC实现如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748String dbDriver = "com.mysql.jdbc.Driver";String url = "jdbc:mysql://localhost:3306/dbname"; String username = "admin"; String password = "admin";String sql = "select * from user where user_name = ? ";Connection conn = null; ResultSet rs = null; PreparedStatement stmt = null; List&lt;Map&lt;String,Object&gt;&gt; resultList = new ArrayList&lt;Map&lt;String,Object&gt;&gt;(); try &#123; // 加载JDBC驱动 Class.forName(dbDriver); // 获取数据库连接 conn = DriverManager.getConnection(url, username, password); // 创建Statement对象 stmt = conn.prepareStatement(sql); // 设置传入参数依次到sql语句中的占位符，位置从1开始 stmt.setString(1, "wang"); // 执行SQL语句 rs = stmt.executeQuery(); // 处理结果集 ResultSetMetaData rsmd = rs.getMetaData(); // 获取列数 int columnCount = rsmd.getColumnCount(); while(rs.next())&#123; Map map = new HashMap(); for(int i = 0; i &lt; columnCount; i++)&#123; // 获取列名 String columnName = rsmd.getColumnName(i+1); map.put(columnName, rs.getString(columnName)); &#125; resultList.add(map); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 释放相关资源 try &#123; // 按创建的相反顺序关闭 rs.close(); stmt.close(); conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet请求转发与重定向]]></title>
    <url>%2F2016%2F03%2F22%2Fweb-servlet-forword-redirect%2F</url>
    <content type="text"><![CDATA[请求转发1request.getRequestDispacther("/hello.jsp").forword(request,response); &nbsp;&nbsp;&nbsp;&nbsp;getRequestDispacther()方法把请求转发给jsp或其它servlet，整个过程都是在服务器端的同一个请求里面完成的，servlet和jsp或其它servlet共用同一个request以及request中设置的属性参数。整个过程是一个请求，一个响应。 重定向1response.sendRedirect("hello.jsp"); &nbsp;&nbsp;&nbsp;&nbsp;sendRedirect()方法向客户端返回响应，告诉客户端再向服务器发送一个请求，去访问指定的jsp或servlet，在客户端接收到这个响应后，立刻发出一个新的请求。两个请求不共享request以及request中设置的属性参数。整个过程是两个请求，两个响应。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MD5加密算法]]></title>
    <url>%2F2015%2F12%2F14%2Falgorithm-md5%2F</url>
    <content type="text"><![CDATA[MD5加密算法&nbsp;&nbsp;&nbsp;&nbsp;MD5常应用于数据加密和信息校验，MD5将文件及文本都当做一个文本信息，通过不可逆的字符串变换算法转换后，产生了一个唯一的MD5信息摘要字符串。这个信息摘要相当于这个文本信息或文件的一个唯一的信息识别，当文本信息或文件被更改后，其通过MD5算法计算后产生的信息摘要字符串也会改变。 加密&nbsp;&nbsp;&nbsp;&nbsp;对密码等重要信息进行MD5加密后，将产生的信息摘要存入数据库。这样即使是管理员也不能看到真实的密码，保障了安全性。在密码验证时，再将密码进行MD5加密后得到的串与数据库中的进行匹配即可。 校验&nbsp;&nbsp;&nbsp;&nbsp;一个文件进行MD5加密后，只会产生了一个唯一的MD5信息摘要字符串。当文件损坏或者被篡改后，再得到的信息摘要就会改变。 密码加密MD5算法1234567891011121314151617181920212223242526import java.io.IOException;import java.io.InputStream;import java.math.BigInteger;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;public static String md5(String plainText) &#123; try &#123; MessageDigest md = MessageDigest.getInstance("MD5"); md.update(plainText.getBytes()); byte b[] = md.digest(); int i = 0; StringBuffer buf = new StringBuffer(""); for (int offset = 0; offset &lt; b.length; offset++) &#123; i = b[offset]; if (i &lt; 0) i += 256; if (i &lt; 16) buf.append("0"); buf.append(Integer.toHexString(i)); &#125; return buf.toString(); &#125; catch (NoSuchAlgorithmException e) &#123; // &#125; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>md5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python简单爬虫-1]]></title>
    <url>%2F2015%2F10%2F14%2Fpython-simpleSpider-1%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;网络爬虫早已不是什么新鲜事物了，我们也经常会用到它去爬取需要的信息。这里介绍一个python3的简单爬虫，主要用urllib库的request去访问网络、bs4库的BeautifulSoup去过滤信息。 1.观察目标网页&nbsp;&nbsp;&nbsp;&nbsp;如果我们需要爬取一个网页中的文字、图片、链接等信息，就需要先去在网页源码中找到需要信息所在的标签。因为我们的爬取过程是先获取整个网页HTML，然后过滤出目标标签，再从标签中提取信息，所以需要先知道目标信息所在的标签。&nbsp;&nbsp;&nbsp;&nbsp;假如我们要获取豆瓣电影的电影信息，首先在浏览器中查看网页源码，一般按快捷键F12就可以查看。 2.获取网页内容&nbsp;&nbsp;&nbsp;&nbsp;使用request访问网页获取HTML内容，为了防止被网站屏蔽，可以通过设置消息头简单模拟成浏览器的访问。浏览器在访问时设置的请求头如下： 获取网页代码如下： 123456789101112131415161718192021222324252627282930from urllib.request import urlopen, Requestfrom urllib.error import HTTPError, URLErrordef getHtml(url): headers = &#123; 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko)Chrome/48.0.2564.116 Safari/537.36'， 'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8', 'Accept-Language':'zh-CN,zh;q=0.8', 'Connection':'keep-alive', 'Host':'movie.douban.com', 'Upgrade-Insecure-Requests':'1', 'Referer':'https://movie.douban.com' &#125; # 设置headers req = Request(url, headers = my_headers) try: #发送请求 response = urlopen(req) #读取返回结果 content = response.read() response.close() except HTTPError as e: #服务器返回错误，具体可看e.code代码 print("HTTPError:", url, e.code) return None except URLError as e: #找不到URL指定主机或无法联网 print("UrlErrorurl:", url, e.reason) return None return content 3.过滤目标内容标签&nbsp;&nbsp;&nbsp;&nbsp;在第一步我们获取到了整个网页的信息，但我们只需要一部分，bs4库的BeautifulSoup可以帮助我们找出目标内容所在的标签。12345678910111213from bs4 import BeautifulSoupdef getMovies(url): html = getHtml(url) if(html != None): try: #创建beautifulsoup对象 bsObj = BeautifulSoup(html, 'html.parser') # 找到html中第一个属性class为lists的ul标签中的所有属性class为list-item的li标签，返回列表 movies = bsObj.find('ul', &#123;"class" : "lists"&#125;).findAll('li', &#123;"class" : "list-item"&#125;) except Exception as e: return None return movies return None 4.从目标标签中获取目标内容&nbsp;&nbsp;&nbsp;&nbsp;在获取到目标内容所在标签后，从标签中提取信息，写入文件或者存入数据库。 123456789101112movies = getMovies(url)for movie in movies: # 从标签中获取'data-title'属性，movie_name为'悟空传' movie_name = movie.attrs['data-title'] # 从标签中获取'data-duration'属性，data-duration为'123分钟' movie_length = movie.attrs['data-duratione'] # 写入文件 filename = os.path.join(file_path, file_name) with open(filename,'a+') as f: f.write(movie_name)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java之输入输出流]]></title>
    <url>%2F2015%2F07%2F14%2Fjava-io%2F</url>
    <content type="text"><![CDATA[流(stream)1、字节流 ① java.io.InputStream 字节输入流，是抽象类。InputStream的方法： public abstract int read() throws IOException从输入流中读取数据的下一个字节，返回下一个数据字节。当到达流末尾时返回 -1。该方法为阻塞方法。 public int read(byte[] b) throws IOException从输入流中读取最多b.length的字节，并将其存储在缓冲区byte数组中。返回实际读取的字节数。如果b的长度为0，则不读取任何字节直接返回0。当到达流末尾时返回 -1。该方法为阻塞方法。 public int read(byte[] b, int off, int len) throws IOException从输入流中将最多len个数据字节读入byte数组。当输入流中实际的字节数少于len个时，读取的字节等于实际字节数。返回实际读取的字节数。如果 len为0，则不读取任何字节直接返回 0。当到达流末尾时返回 -1。该方法为阻塞方法。 public void close() throws IOException关闭输入流并释放相关系统资源。 public long skip(long n) throws IOException从输入流中跳过n个字节。返回跳过的实际字节数。当没跳过任何字节时，返回负数。跳过的字节数有可能小于n，也可能为 0。比如存在跳完n个字节之前就已到达文件末尾、跳时就已到达文件末尾等情况。 public int available() throws IOException public void mark(int readlimit)在输入流中标记当前的位置。 public void reset() throws IOException将输入流重新定位到最后一次对此输入流调用mark方法时的位置。 public boolean markSupported()查询输入流是否支持mark和reset方法。 InputStream的常用子类： FileInputStream 从文件中读取字节流 ByteArrayInputStream 从数组中读取字节流 ObjectInputStream 从序列化对象文件中读取字节流 PipeInputStream 从管道中读取字节流 SequenceInputStream 将多个字节流合并后依次读取 AudioInputStream 从音频文件中读取字节流 FilterInputStream ② java.io.OutputStream 字节输出流，是抽象类。OutputStream的方法： public abstract void write(int b) throws IOException将字节写入此输出流。 public void write(byte[] b) throws IOException将byte数组写入此输出流。 public void write(byte[] b, int off, int len) throws IOException将byte数组中从偏移量off开始的len个字节写入输出流。 public void flush() throws IOException刷新输出流并强制写出所有缓冲的输出字节。 public void close() throws IOException关闭输出流并释放相关系统资源。 OutputStream的常用子类： FileOutputStream ObjectOutputStream PipeOutputStream FilterOutputStream ByteArrayOutputStream FilterOutputStream 2、字符流①java.io.Reader 字符输入流，是抽象类。Reader的子类： BufferedReader InputStreamReader FileReader StringReader CharArrayReader PipedReader FilterReader ②java.io.Writer 字符输出流，是抽象类。Writer的子类： BufferedWriter OutputStreamWriter FileWriter StringWriter CharArrayWriter PipedWriter FilterWriter PrintWriter]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>io</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用排序算法]]></title>
    <url>%2F2015%2F07%2F08%2Falgorithm-sort%2F</url>
    <content type="text"><![CDATA[常见排序算法：插入排序(直接插入排序、二分插入排序、希尔插入排序)、选择排序(直接选择排序、堆排序)、交换排序(冒泡排序、快速排序)、归并排序、基数排序。不同的排序算法的时间复杂度、空间复杂度以及稳定性比较如下表: 以下为其java实现： 1、直接插入排序1234567891011121314151617181920212223242526272829/* * 直接插入排序 * 类型：插入排序 * 稳定 * 最优时间复杂度：\\(O(n) * 最坏时间复杂度：\\(O(n^2) * 平均时间复杂度：\\(O(n^2) * 空间复杂度： \\(O(1) * */ public static void insertSort(int[] array)&#123; int end = array.length - 1; int temp = 0; //以第0个数为有序序列 for(int i = 1; i &lt;= end; i++)&#123; //将后边的数一次按大小插入前面的有序序列中，构成新的有序序列 for(int j = i-1; j &gt;= 0; j--)&#123; //交换 if(array[j] &gt; array[j + 1])&#123; temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; //若不小于序列中最后一个数，直接开始下一次插入 &#125;else&#123; break; &#125; &#125; &#125; &#125; 2、二分插入排序1234567891011121314151617181920212223242526272829303132333435363738/* * 二分插入排序 * 类型：插入排序 * 稳定 * 最优时间复杂度：\\(O(nn*logn) * 最坏时间复杂度：\\(O(nn*logn) * 平均时间复杂度：\\(O(n^2) * 空间复杂度： \\(O(1) * */ public static void binaryInsertSort(int[] array)&#123; int end = array.length - 1; int temp, left, right, mid; for(int i = 1; i &lt;= end; i++)&#123; left = 0; right = i - 1; //以二分法找到要插入的位置，减少了比较次数 while(left &lt;= right)&#123; mid = (left + right) / 2; if(array[mid] == array[i])&#123; left = mid + 1; break; &#125;else if(array[mid] &lt; array[i])&#123; left = mid + 1; &#125;else&#123; right = mid - 1; &#125; &#125; if(left != i)&#123; //插入以及其他元素后移 temp = array[i]; for(int k = i; k &gt; left; k--)&#123; array[k] = array[k-1]; &#125; array[left] = temp; &#125; &#125; &#125; 3、希尔插入排序1234567891011121314151617181920212223242526272829303132/* * 希尔排序 * 类型：插入排序 * 不稳定 * 最优时间复杂度：\\(O(n) * 最坏时间复杂度：\\(O(n^2) * 平均时间复杂度：\\(O(n^1.5) * 空间复杂度： \\(O(1) * */ public static void ShellSort(int[] array)&#123; int length = array.length; int temp; //计算增量 for (int increment = length / 2; increment &gt;= 1; increment /= 2) &#123; //每个增量下，子序列数量 for(int i = 0; i &lt; increment; i++)&#123; //子序列插入排序 for(int j = i + increment; j &lt; length; j += increment)&#123; for(int k = j ; k &gt; i; k -= increment)&#123; if(array[k] &lt; array[k - increment])&#123; temp = array[k]; array[k] = array[k - increment]; array[k - increment] = temp; &#125;else&#123; break; &#125; &#125; &#125; &#125; &#125; &#125; 4、直接选择排序123456789101112131415161718192021222324252627282930/* * 直接选择排序 * 类型：选择排序 * 不稳定 * 最优时间复杂度：\\(O(n^2) * 最坏时间复杂度：\\(O(n^2) * 平均时间复杂度：\\(O(n^2) * 空间复杂度： \\(O(1) * */ public static void selectSort(int[] array)&#123; int temp = 0, maxIndex; int end = array.length - 1; //遍历，找最小数依次交换到序列前部 for(int i = 0; i &lt; end ; i++)&#123; //设置最小值下标 maxIndex = i; //在有序序列后面，遍历寻找最小数，记录下标 for(int j = i + 1; j &lt;= end; j++)&#123; if(array[j] &lt; array[maxIndex])&#123; maxIndex = j; &#125; &#125; if(maxIndex != i)&#123; temp = array[i]; array[i] = array[maxIndex]; array[maxIndex] = temp; &#125; &#125; &#125; 5、堆排序12 6、冒泡排序123456789101112131415161718192021222324252627/* * 冒泡排序 * 类型：交换排序 * 稳定 * 最优时间复杂度：\\(O(n) * 最坏时间复杂度：\\(O(n^2) * 平均时间复杂度：\\(O(n^2) * 空间复杂度： \\(O(1) * */ public static void bubbleSort(int[] array)&#123; int end = array.length - 1; int temp; boolean tag = true; for (int i = 0; i &lt; end &amp;&amp; tag; i++) &#123; tag = false; //将较大的数依次冒泡到序列尾部 for (int j = 0; j &lt; end - i; j++) &#123; if(array[j] &gt; array[j+1])&#123; temp = array[j]; array[j] = array[j+1]; array[j+1] = temp; tag = true; &#125; &#125; &#125; &#125; 7、快速排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* * 快速排序 * 类型：交换排序 * 不稳定 * 最优时间复杂度：\\(O(nn*logn) * 最坏时间复杂度：\\(O(n^2) * 平均空间复杂度：\\(O(nn*logn) * param: * start 列表起始index * end 列表结束index * */ public static void quickSort(int[] array, int start, int end)&#123; //递归结束条件 if(start &gt;= end)&#123; return; &#125; //取第一个数设为key值，之后将列表中比它小的数放在它左边，将比它大的数放在它右边 int key = array[start]; //设置左右游标 int l = start,r = end; while(l &lt; r)&#123; // 先从右边开始比较，如果该值大于等于key，右游标前移 while(l &lt; r &amp;&amp; array[r] &gt;= key)&#123; r--;; &#125; if(l &lt; r)&#123; //找到比key小的值，赋值给左游标处的值 array[l] = array[r]; //左游标后移 l++; &#125; // 再从左边开始比较，如果该值小于key，左游标后移 while(l &lt; r &amp;&amp; array[l] &lt; key)&#123; l++; &#125; if(l &lt; r)&#123; //找到比key大的值，赋值给右游标处的值 array[r] = array[l]; //右游标前移 r--; &#125; &#125; // 一次排序结束，将key放到中间 array[l] = key; //对key左边的序列快排 quickSort(array, start, l); //对key右边的序列快排 quickSort(array, l+1, end); &#125; 8、归并排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* * 归并排序 * 稳定 * 最优时间复杂度：\\(O(nn*logn) * 最坏时间复杂度：\\(O(nn*logn) * 平均时间复杂度：\\(O(nn*logn) * 空间复杂度： \\(O(1) * */ public static void mergeSort(int[] array, int start, int end, int[] temp)&#123; if(start &lt; end)&#123; int mid = (start + end) / 2; //左边继续归并排序 mergeSort(array, start, mid, temp); //右边继续归并排序 mergeSort(array, mid + 1, end, temp); //合并左右两边 mergeArray(array, start, mid, end, temp); &#125; &#125; /* * 数组合并 */ public static void mergeArray(int[] array, int first, int mid, int last, int[] temp)&#123; int i = first, j = mid + 1, k = 0; int m = mid, n = last; //合并两个有序数组到临时数组，依次先取较小的放入 while(i &lt;= m &amp;&amp; j &lt;= n)&#123; if(array[i] &lt;= array[j])&#123; temp[k++] = array[i++]; &#125;else&#123; temp[k++] = array[j++]; &#125; &#125; //如果两个数组长度不等，将较长数组中剩下的数放入合并后的数组中 while(i &lt;= m)&#123; temp[k++] = array[i++]; &#125; while(j &lt;= n)&#123; temp[k++] = array[j++]; &#125; //将合并后的数组复制到原数组 for(i = 0; i&lt; k; i++)&#123; array[first + i] = temp[i]; &#125; &#125; 9、基数排序12]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Test]]></title>
    <url>%2F2015%2F01%2F14%2Ftest%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
</search>
